// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil; -*-
// @BEGIN_LICENSE
//
// Halyard - Multimedia authoring and playback system
// Copyright 1993-2009 Trustees of Dartmouth College
// 
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// @END_LICENSE

#ifndef UrlRequest_H
#define UrlRequest_H

#include "InvisibleElement.h"

// These typedefs should match those in curl/curl.h.  We re-declare them
// here so that we don't need to include curl/curl.h in this header file.
typedef void CURL;
struct CURLMsg;
struct curl_slist;

/// An asynchronous HTTP (FTP, etc.) request, implemented using libcurl.
/// We implement this as an element, because doing so gives us easy access
/// to lifecycle management and an event dispatcher.
class UrlRequest : public InvisibleElement {
    typedef std::map<CURL*,UrlRequest*> RequestMap;

    /// Maps all existing CURL 'easy handles' to the corresponding
    /// UrlRequest.
    static RequestMap sRequests;

    /// We need to keep track of the relationship between gCurlMultiHandle
    /// (a CURL multi handle), and mHandle (a CURL easy handle), or we will
    /// get terribly confused.
    enum State {
        INITIALZING,     //< We're still setting up mHandle.
        STARTED,         //< mHandle is attached to gCurlMultiHandle.
        STOPPED          //< mHandle is detached from gCurlMultiHandle.
    };

    /// What is the current state of this request?
    State mState;

    /// A CURL "easy handle" handle representing this request.
    CURL *mHandle;

    /// A list of headers to send with the request.
    struct curl_slist *mHeaders;

    static int ProgressCallback(void *data, double dltotal, double dlnow, 
                                double ultotal, double ulnow);
    static size_t WriteCallback(char* ptr, size_t size, size_t nmemb,
                                void *data);

    /// Called when data is transferred.
    int DoProgress(double dltotal, double dlnow,
                   double ultotal, double ulnow);

    /// Called when data needs to be written.
    size_t DoWrite(char* ptr, size_t size, size_t nmemb);

    /// Called when we receive a message about this request via the multi
    /// handle.
    void HandleMessage(struct CURLMsg *inMsg);

public:
    /// Initialize libcurl.
    static void Initialize();

    /// Clean up libcurl.
    static void Cleanup();

    /// Run idle-time tasks for all outstanding UrlRequest objects.
    static void ProcessAllRequests();

    // Encode the specified string for use in a URL parameter.
    static std::string PercentEncode(const std::string &inStr);

    /// Do any proxy server configuration needed for inHandle, assuming we
    /// want to download inUrl.  Note that this is a public, static
    /// function (and not a private member function) so that we can call it
    /// from Downloader.cpp.
    static void ConfigureProxyServer(CURL *inHandle, const wxString &inUrl);

    /// Create a new asynchronous URL request.
    UrlRequest(const wxString &inName,
               Halyard::TCallbackPtr inDispatcher,
               const wxString &inUrl);

    virtual ~UrlRequest();

    /// Configure this URL request as a POST.
    void ConfigurePost(const std::string &inContentType,
                       const std::string &inBody);

    /// Specify a request header value.  These values override any default
    /// values generated by CURL.  To prevent a header from being sent,
    /// pass a value of "".
    void ConfigureSetHeader(const std::string &inHeader,
                            const std::string &inValue);

    /// Start the URL request.
    void Start();

    /// Abort a running URL request.
    void Stop();

    /// Return the MIME type of the response, or "" if the MIME type is
    /// unknown.
    std::string GetResponseContentType();
};

#endif // UrlRequest_H
